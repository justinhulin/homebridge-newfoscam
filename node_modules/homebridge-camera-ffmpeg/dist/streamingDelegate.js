"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StreamingDelegate = void 0;
const child_process_1 = require("child_process");
const dgram_1 = require("dgram");
const ffmpeg_for_homebridge_1 = __importDefault(require("ffmpeg-for-homebridge"));
const get_port_1 = __importDefault(require("get-port"));
const os_1 = __importDefault(require("os"));
const systeminformation_1 = require("systeminformation");
const ffmpeg_1 = require("./ffmpeg");
class StreamingDelegate {
    constructor(log, cameraConfig, api, hap, videoProcessor, interfaceName) {
        this.pendingSessions = {};
        this.ongoingSessions = {};
        this.timeouts = {};
        this.log = log;
        this.videoConfig = cameraConfig.videoConfig;
        this.hap = hap;
        this.cameraName = cameraConfig.name;
        this.videoProcessor = videoProcessor || ffmpeg_for_homebridge_1.default || 'ffmpeg';
        this.interfaceName = interfaceName;
        api.on("shutdown", () => {
            for (const session in this.ongoingSessions) {
                this.stopStream(session);
            }
        });
        const options = {
            cameraStreamCount: cameraConfig.videoConfig.maxStreams || 2,
            delegate: this,
            streamingOptions: {
                supportedCryptoSuites: [0],
                video: {
                    resolutions: [
                        [320, 180, 30],
                        [320, 240, 15],
                        [320, 240, 30],
                        [480, 270, 30],
                        [480, 360, 30],
                        [640, 360, 30],
                        [640, 480, 30],
                        [1280, 720, 30],
                        [1280, 960, 30],
                        [1920, 1080, 30],
                        [1600, 1200, 30]
                    ],
                    codec: {
                        profiles: [0, 1, 2],
                        levels: [0, 1, 2]
                    }
                },
                audio: {
                    twoWayAudio: !!this.videoConfig.returnAudioTarget,
                    codecs: [
                        {
                            type: "AAC-eld",
                            samplerate: 16
                        }
                    ]
                }
            }
        };
        this.controller = new hap.CameraController(options);
    }
    determineResolution(request, isSnapshot) {
        var _a;
        let width = request.width;
        let height = request.height;
        if (!isSnapshot) {
            if ((this.videoConfig.forceMax && this.videoConfig.maxWidth) ||
                (request.width > this.videoConfig.maxWidth)) {
                width = this.videoConfig.maxWidth;
            }
            if ((this.videoConfig.forceMax && this.videoConfig.maxHeight) ||
                (request.height > this.videoConfig.maxHeight)) {
                height = this.videoConfig.maxHeight;
            }
        }
        const filters = ((_a = this.videoConfig.videoFilter) === null || _a === void 0 ? void 0 : _a.split(',')) || [];
        const noneFilter = filters.indexOf('none');
        if (noneFilter >= 0) {
            filters.splice(noneFilter, 1);
        }
        if (noneFilter < 0) {
            if (width > 0 || height > 0) {
                filters.push('scale=' + (width > 0 ? '\'min(' + width + ',iw)\'' : 'iw') + ':' +
                    (height > 0 ? '\'min(' + height + ',ih)\'' : 'ih') +
                    ':force_original_aspect_ratio=decrease');
                filters.push('scale=trunc(iw/2)*2:trunc(ih/2)*2');
            }
        }
        return {
            width: width,
            height: height,
            videoFilter: filters.join(',')
        };
    }
    handleSnapshotRequest(request, callback) {
        const resolution = this.determineResolution(request, true);
        this.log.debug('Snapshot requested: ' + request.width + ' x ' + request.height, this.cameraName, this.videoConfig.debug);
        this.log.debug('Sending snapshot: ' + (resolution.width > 0 ? resolution.width : 'native') + ' x ' +
            (resolution.height > 0 ? resolution.height : 'native'), this.cameraName, this.videoConfig.debug);
        let ffmpegArgs = this.videoConfig.stillImageSource || this.videoConfig.source;
        ffmpegArgs +=
            ' -frames:v 1' +
                (resolution.videoFilter ? ' -filter:v ' + resolution.videoFilter : '') +
                ' -f image2 -';
        try {
            const ffmpeg = child_process_1.spawn(this.videoProcessor, ffmpegArgs.split(/\s+/), { env: process.env });
            let imageBuffer = Buffer.alloc(0);
            this.log.debug('Snapshot command: ' + this.videoProcessor + ' ' + ffmpegArgs, this.cameraName, this.videoConfig.debug);
            ffmpeg.stdout.on('data', (data) => {
                imageBuffer = Buffer.concat([imageBuffer, data]);
            });
            const log = this.log;
            ffmpeg.on('error', (error) => {
                log.error('An error occurred while making snapshot request: ' + error, this.cameraName);
            });
            ffmpeg.on('close', () => {
                callback(undefined, imageBuffer);
            });
        }
        catch (err) {
            this.log.error(err, this.cameraName);
            callback(err);
        }
    }
    async getIpAddress(ipv6, interfaceName) {
        var _a;
        if (!interfaceName) {
            interfaceName = await systeminformation_1.networkInterfaceDefault();
        }
        const interfaces = os_1.default.networkInterfaces();
        const externalInfo = (_a = interfaces[interfaceName]) === null || _a === void 0 ? void 0 : _a.filter((info) => {
            return !info.internal;
        });
        const preferredFamily = ipv6 ? 'IPv6' : 'IPv4';
        const addressInfo = (externalInfo === null || externalInfo === void 0 ? void 0 : externalInfo.find((info) => {
            return info.family === preferredFamily;
        })) || (externalInfo === null || externalInfo === void 0 ? void 0 : externalInfo[0]);
        if (!addressInfo) {
            throw new Error('Unable to get network address for "' + interfaceName + '"!');
        }
        return addressInfo.address;
    }
    async prepareStream(request, callback) {
        const videoReturnPort = await get_port_1.default();
        const videoSSRC = this.hap.CameraController.generateSynchronisationSource();
        const audioReturnPort = await get_port_1.default();
        const audioSSRC = this.hap.CameraController.generateSynchronisationSource();
        const ipv6 = request.addressVersion === 'ipv6';
        let currentAddress;
        try {
            currentAddress = await this.getIpAddress(ipv6, this.interfaceName);
        }
        catch (ex) {
            if (this.interfaceName) {
                this.log.warn(ex + ' Falling back to default.', this.cameraName);
                currentAddress = await this.getIpAddress(ipv6);
            }
            else {
                throw ex;
            }
        }
        const sessionInfo = {
            address: request.targetAddress,
            localAddress: currentAddress,
            ipv6: ipv6,
            videoPort: request.video.port,
            videoReturnPort: videoReturnPort,
            videoCryptoSuite: request.video.srtpCryptoSuite,
            videoSRTP: Buffer.concat([request.video.srtp_key, request.video.srtp_salt]),
            videoSSRC: videoSSRC,
            audioPort: request.audio.port,
            audioReturnPort: audioReturnPort,
            audioCryptoSuite: request.audio.srtpCryptoSuite,
            audioSRTP: Buffer.concat([request.audio.srtp_key, request.audio.srtp_salt]),
            audioSSRC: audioSSRC
        };
        const response = {
            address: currentAddress,
            video: {
                port: videoReturnPort,
                ssrc: videoSSRC,
                srtp_key: request.video.srtp_key,
                srtp_salt: request.video.srtp_salt
            },
            audio: {
                port: audioReturnPort,
                ssrc: audioSSRC,
                srtp_key: request.audio.srtp_key,
                srtp_salt: request.audio.srtp_salt
            }
        };
        this.pendingSessions[request.sessionID] = sessionInfo;
        callback(undefined, response);
    }
    startStream(request, callback) {
        var _a;
        const sessionInfo = this.pendingSessions[request.sessionID];
        const vcodec = this.videoConfig.vcodec || 'libx264';
        const mtu = this.videoConfig.packetSize || 1316;
        let encoderOptions = this.videoConfig.encoderOptions;
        if (!encoderOptions && vcodec === 'libx264') {
            encoderOptions = '-preset ultrafast -tune zerolatency';
        }
        const resolution = this.determineResolution(request.video, false);
        let fps = (this.videoConfig.forceMax && this.videoConfig.maxFPS) ||
            (request.video.fps > this.videoConfig.maxFPS) ?
            this.videoConfig.maxFPS : request.video.fps;
        let videoBitrate = (this.videoConfig.forceMax && this.videoConfig.maxBitrate) ||
            (request.video.max_bit_rate > this.videoConfig.maxBitrate) ?
            this.videoConfig.maxBitrate : request.video.max_bit_rate;
        if (vcodec === 'copy') {
            resolution.width = 0;
            resolution.height = 0;
            resolution.videoFilter = '';
            fps = 0;
            videoBitrate = 0;
        }
        this.log.debug('Video stream requested: ' + request.video.width + ' x ' + request.video.height + ', ' +
            request.video.fps + ' fps, ' + request.video.max_bit_rate + ' kbps', this.cameraName, this.videoConfig.debug);
        this.log.info('Starting video stream: ' + (resolution.width > 0 ? resolution.width : 'native') + ' x ' +
            (resolution.height > 0 ? resolution.height : 'native') + ', ' + (fps > 0 ? fps : 'native') +
            ' fps, ' + (videoBitrate > 0 ? videoBitrate : '???') + ' kbps', this.cameraName);
        let ffmpegArgs = this.videoConfig.source;
        ffmpegArgs +=
            (this.videoConfig.mapvideo ? ' -map ' + this.videoConfig.mapvideo : ' -an -sn -dn') +
                ' -codec:v ' + vcodec +
                ' -pix_fmt yuv420p' +
                ' -color_range mpeg' +
                (fps > 0 ? ' -r ' + fps : '') +
                ' -f rawvideo' +
                (encoderOptions ? ' ' + encoderOptions : '') +
                (resolution.videoFilter.length > 0 ? ' -filter:v ' + resolution.videoFilter : '') +
                (videoBitrate > 0 ? ' -b:v ' + videoBitrate + 'k' : '') +
                ' -payload_type ' + request.video.pt;
        ffmpegArgs +=
            ' -ssrc ' + sessionInfo.videoSSRC +
                ' -f rtp' +
                ' -srtp_out_suite AES_CM_128_HMAC_SHA1_80' +
                ' -srtp_out_params ' + sessionInfo.videoSRTP.toString('base64') +
                ' srtp://' + sessionInfo.address + ':' + sessionInfo.videoPort +
                '?rtcpport=' + sessionInfo.videoPort + '&pkt_size=' + mtu;
        if (this.videoConfig.audio) {
            ffmpegArgs +=
                (this.videoConfig.mapaudio ? ' -map ' + this.videoConfig.mapaudio : ' -vn -sn -dn') +
                    ' -codec:a libfdk_aac' +
                    ' -profile:a aac_eld' +
                    ' -flags +global_header' +
                    ' -f null' +
                    ' -ar ' + request.audio.sample_rate + 'k' +
                    ' -b:a ' + request.audio.max_bit_rate + 'k' +
                    ' -ac ' + request.audio.channel +
                    ' -payload_type ' + request.audio.pt;
            ffmpegArgs +=
                ' -ssrc ' + sessionInfo.audioSSRC +
                    ' -f rtp' +
                    ' -srtp_out_suite AES_CM_128_HMAC_SHA1_80' +
                    ' -srtp_out_params ' + sessionInfo.audioSRTP.toString('base64') +
                    ' srtp://' + sessionInfo.address + ':' + sessionInfo.audioPort +
                    '?rtcpport=' + sessionInfo.audioPort + '&pkt_size=188';
        }
        if (this.videoConfig.debug) {
            ffmpegArgs += ' -loglevel level+verbose';
        }
        const activeSession = {};
        activeSession.socket = dgram_1.createSocket(sessionInfo.ipv6 ? 'udp6' : 'udp4');
        activeSession.socket.on('error', (err) => {
            this.log.error('Socket error: ' + err.name, this.cameraName);
            this.stopStream(request.sessionID);
        });
        activeSession.socket.on('message', () => {
            if (activeSession.timeout) {
                clearTimeout(activeSession.timeout);
            }
            activeSession.timeout = setTimeout(() => {
                this.log.info('Device appears to be inactive. Stopping stream.', this.cameraName);
                this.controller.forceStopStreamingSession(request.sessionID);
                this.stopStream(request.sessionID);
            }, request.video.rtcp_interval * 2 * 1000);
        });
        activeSession.socket.bind(sessionInfo.videoReturnPort, sessionInfo.localAddress);
        activeSession.mainProcess = new ffmpeg_1.FfmpegProcess(this.cameraName, request.sessionID, this.videoProcessor, ffmpegArgs, this.log, this.videoConfig.debug, this, callback);
        if (this.videoConfig.returnAudioTarget) {
            let ffmpegReturnArgs = '-hide_banner' +
                ' -protocol_whitelist pipe,udp,rtp,file,crypto' +
                ' -f sdp' +
                ' -c:a libfdk_aac' +
                ' -i pipe:' +
                ' ' + this.videoConfig.returnAudioTarget;
            if (this.videoConfig.debugReturn) {
                ffmpegReturnArgs += ' -loglevel level+verbose';
            }
            const ipVer = sessionInfo.ipv6 ? 'IP6' : 'IP4';
            const sdpReturnAudio = 'v=0\r\n' +
                'o=- 0 0 IN ' + ipVer + ' ' + sessionInfo.address + '\r\n' +
                's=Talk\r\n' +
                'c=IN ' + ipVer + ' ' + sessionInfo.address + '\r\n' +
                't=0 0\r\n' +
                'm=audio ' + sessionInfo.audioReturnPort + ' RTP/AVP 110\r\n' +
                'b=AS:24\r\n' +
                'a=rtpmap:110 MPEG4-GENERIC/16000/1\r\n' +
                'a=rtcp-mux\r\n' +
                'a=fmtp:110 ' +
                'profile-level-id=1;mode=AAC-hbr;sizelength=13;indexlength=3;indexdeltalength=3; ' +
                'config=F8F0212C00BC00\r\n' +
                'a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:' + sessionInfo.audioSRTP.toString('base64') + '\r\n';
            activeSession.returnProcess = new ffmpeg_1.FfmpegProcess(this.cameraName + '] [Two-way', request.sessionID, this.videoProcessor, ffmpegReturnArgs, this.log, this.videoConfig.debugReturn, this);
            (_a = activeSession.returnProcess.getStdin()) === null || _a === void 0 ? void 0 : _a.end(sdpReturnAudio);
        }
        this.ongoingSessions[request.sessionID] = activeSession;
        delete this.pendingSessions[request.sessionID];
    }
    handleStreamRequest(request, callback) {
        switch (request.type) {
            case "start":
                this.startStream(request, callback);
                break;
            case "reconfigure":
                this.log.debug('Received request to reconfigure: ' + request.video.width + ' x ' + request.video.height + ', ' +
                    request.video.fps + ' fps, ' + request.video.max_bit_rate + ' kbps (Ignored)', this.cameraName, this.videoConfig.debug);
                callback();
                break;
            case "stop":
                this.stopStream(request.sessionID);
                callback();
                break;
        }
    }
    stopStream(sessionId) {
        var _a, _b, _c;
        const session = this.ongoingSessions[sessionId];
        if (session) {
            if (session.timeout) {
                clearTimeout(session.timeout);
            }
            try {
                (_a = session.socket) === null || _a === void 0 ? void 0 : _a.close();
            }
            catch (err) {
                this.log.error('Error occurred closing socket: ' + err, this.cameraName);
            }
            try {
                (_b = session.mainProcess) === null || _b === void 0 ? void 0 : _b.stop();
            }
            catch (err) {
                this.log.error('Error occurred terminating main FFmpeg process: ' + err, this.cameraName);
            }
            try {
                (_c = session.returnProcess) === null || _c === void 0 ? void 0 : _c.stop();
            }
            catch (err) {
                this.log.error('Error occurred terminating two-way FFmpeg process: ' + err, this.cameraName);
            }
        }
        delete this.ongoingSessions[sessionId];
        this.log.info('Stopped video stream.', this.cameraName);
    }
}
exports.StreamingDelegate = StreamingDelegate;
//# sourceMappingURL=streamingDelegate.js.map